<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video Streaming with Chunking</title>
</head>
<body>
  <video id="video" controls width="600"></video>

  <h3>Status Console</h3>
  <textarea id="statusConsole" rows="10" cols="50" readonly></textarea>

  <script>
    const video = document.getElementById('video');
    const statusConsole = document.getElementById('statusConsole');
    
    const baseUrl = "@ipaddress/clownwire/media/stream";  // Update this URL as needed
    let currentStartByte = 0;
    const chunkSize =  1024; //1024 chunk
    let totalFileSize = 0;
    let minute = 0; 
    let total_minutes = 0; 
    let isBuffering = false;
    
    // This will hold the MediaSource object for the video
    let mediaSource = new MediaSource();  // Create a MediaSource object
    let sourceBuffer;

    // Set the video source to use the MediaSource
    video.src = URL.createObjectURL(mediaSource);
    
    // When the MediaSource is open, prepare the source buffer
    mediaSource.addEventListener('sourceopen', () => {
      sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8, vorbis"');  // Adjust MIME type based on your video format
      loadNextChunk();
    });

    // Function to load the next video segment (in bytes)
    function loadNextChunk() {
      
      if (isBuffering || !sourceBuffer) return;  // Avoid fetching if already buffering or sourceBuffer is not ready
      isBuffering = true;
      minute++;

      const segmentUrl = `${baseUrl}`;
      
      fetch(segmentUrl, {
        method: 'GET',
        headers: {
          'Range': `bytes=${currentStartByte}-${currentStartByte + chunkSize - 1}`,
          'Minute': `${minute}`,
        }
      })
      .then(response => {
        if (response.status === 206) {  // If partial content is returned (HTTP 206)
          const reader = response.body.getReader();
          const chunks = [];
          
          reader.read().then(function processText({ done, value }) {
            if (done) {
             
              // End of stream, we can append the chunk to the buffer
              const uint8Array = new Uint8Array(chunks.reduce((acc, chunk) => acc.concat(Array.from(chunk)), []));
              sourceBuffer.appendBuffer(uint8Array);
              isBuffering = false;
              currentStartByte += uint8Array.length;  // Move the start time for the next chunk
              // Continue loading more chunks if we have not reached the end
              if (currentStartByte < totalFileSize) {
                loadNextChunk();
              }
              return;
            }
            chunks.push(value);  // Collect chunk data
            reader.read().then(processText);  // Continue reading
          });
        } else {
          console.error('Failed to fetch video chunk:', response.statusText);
          isBuffering = false;
        }
      })
      .catch(error => {
        console.error('Error fetching video chunk:', error);
        isBuffering = false;
      });
    }

    // When video can start playing, fetch more chunks
    video.addEventListener('canplay', () => {
      video.play();
    });

    // Handle buffering and chunking in the video stream
    video.addEventListener('waiting', () => {
      console.log('Buffering...');
    });

    video.addEventListener('playing', () => {
      console.log('Playing...');
    });

    // This event is triggered when the video has ended
    video.addEventListener('ended', () => {
      console.log('Video ended, loading next segment...');
      loadNextChunk();  // Load the next segment when the current one ends
    });

    // Get video file size and begin streaming
    fetch(baseUrl, { method: 'HEAD' })
      .then(response => {
        totalFileSize = parseInt(response.headers.get('Content-Length'), 10);  // Get total file size
        total_minutes = parseInt(response.headers.get('Total-Minutes'), 10);  // Get total file size
        console.log('Total file size:', totalFileSize);
      })
      .catch(error => {
        console.error('Error fetching file size:', error);
      });
  </script>
</body>
</html>
